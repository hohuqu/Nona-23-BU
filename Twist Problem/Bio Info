import os
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt

def oligo_to_dna(oligo):
    """
    Convert an oligonucleotide to a DNA sequence.

    Args:
        oligo (str): Oligonucleotide sequence using single-letter codes.

    Returns:
        str: DNA sequence.
    """
    conversion_dict = {
        'A': 'A',
        'C': 'C',
        'G': 'G',
        'T': 'T',
        'U': 'T',  # Assuming U (uracil) is converted to T (thymine)
        'R': 'AG',  # Purine (A or G)
        'Y': 'CT',  # Pyrimidine (C or T)
        'M': 'AC',  # Amino (A or C)
        'K': 'GT',  # Keto (G or T)
        'S': 'GC',  # Strong interaction (C or G)
        'W': 'AT',  # Weak interaction (A or T)
        'B': 'CGT',  # Not A (C or G or T)
        'D': 'AGT',  # Not C (A or G or T)
        'H': 'ACT',  # Not G (A or C or T)
        'V': 'ACG',  # Not T/U (A or C or G)
        'N': 'ACGT'  # Any base (A or C or G or T)
    }

    dna_sequence = ''.join(conversion_dict.get(base, '') for base in oligo.upper())
    return dna_sequence

class SeqRecord:
    '''
    Encapsulates both the sequence and features of a given
    genome. Identified by an accession number for the organism (e.g. U00096.3).
    A SeqRecord object contains one Sequence object and a list of Feature
    objects for that sequence.
    '''
    
    '''Attribute for id count (for features w/o explicit id)'''
    id_count = 0
    
    def __init__(self,genome_directory,sequence='',features=[]): #remove: genome_directory,feature_list=[],sequence,features,
        '''Creates FileNode and FileSystem for genome directory'''
        self.rootdir = fs_graph.FileNode(genome_directory)
        
        '''Gets the directory for the .gff & .fa file and other attributes'''
        
        # Get list of all files in directory
        file_list = os.listdir(genome_directory)
        
        # Filter list for .gff files
        gff_files = [file for file in file_list if file.endswith('.gff')]
        
        
        self.accession = self.rootdir.basename()
        self.filedir_gff = os.path.join(str(self.rootdir) + "/" + str(gff_files[0]))
        #self.filedir_gff = os.path.join(str(self.rootdir),str(self.accession) + '.gff')
        #self.filedir_fa = os.path.join(str(self.rootdir),str(self.accession) + '.fa')
        
        '''Sequence and Feature attributes'''
        #self.sequence = 0
        #self.sequence = Sequence(self.filedir_fa)
        self.features = features
        
        '''Attribute for filter runs'''
        self.filter_runs = 0
    
    def __iter__(self): #iterable support
        self.count = -1
        return self
    
    def __next__(self): #iterable support
        while self.count <= len(self.features):
            self.count += 1
            return self.features[self.count].read
        raise(StopIteration)
    
    def parse_gff(self):
        '''
        Takes a path to the corresponding gff file and returns a list of
        feature objects (can include derived feature object)
        '''
        self.opt_attributes = []
        self.attributes = ['seqname','source','type','start','end','score','strand','frame']
        
        gff_file = open(self.filedir_gff)
        print("Success! Now parsing file...")
        with gff_file as f:
            for line in f:
                feature = Feature(line)
                subtypes = Subtypes(line)
                self.features.append(feature)
                self.features.append(subtypes)
                
                SeqRecord.id_count += 1
     
                '''finds optional attributes'''
                s = line.rstrip('\n') #Removes new line 
                s = s.split('\t') #Removes tabs
                s_opt = s[8].replace(';','~') #s[8] refers to optional attributes
                s_opt = s_opt.replace('=','~')
                s_opt = s_opt.split('~')
                self.opt_attributes.append(s_opt)
        print("Parsed " + str(int(len(self.features)/2)) + " features")
        print("\n")
        return self.features
    
    def filter(self,search):
        '''
        - Filter out the features for only those that match the arguments provided
        - Create and return a new SeqRecord object with the same sequence but
        only the features that pass the filter
        - How you pass arguments to filter() is up to you, but it should mimic
        the results of your gff_filter.py script.  In fact, you should consider
        pulling code from gff_filter.py.  And it should make it easy to
        implement seqrec_filter.py as described below.
        '''
        if search == '' or search == 'q':
            print("Thank you using our services! Please come again soon!")
            return ''
        elif search == 'back' or search == 'fasta' or search == 'full':
            attribute = search
        
        strings = ['back','fasta','full']
        search = search.split()
        if len(search) == 3:
            attribute = search[0]
        elif len(search) == 2:
            attribute = search[0]
            value = search[1]
            
        results_list = []
        j = 0
        for i in range(int(len(self.features)/2)):
            #combines the main and optional attributes of features
            l = self.features[i+j].read + "\t" + self.features[i+j+1].read
            l = l.split("\t")

            if len(search) == 3: #start/end pos1 pos2
                if attribute == 'start':
                    start = int(l[3])
                    if (start >= int(search[1]) and start <= int(search[2])):
                        results_list.append(self.features[i+j])
                        results_list.append(self.features[i+j+1])
                elif attribute == 'end':
                    end = int(l[4])
                    if (end >= int(search[1]) and end <= int(search[2])):
                        results_list.append(self.features[i])
            elif len(search) == 2: #attribute string
                #Main Attributes
                if self.attributes.count(attribute) != 0:
                    attribute_index = self.attributes.index(attribute)
                    if l[attribute_index] == value:
                        results_list.append(self.features[i+j])
                        results_list.append(self.features[i+j+1])
                else: #Extra Attributes
                    n = 0
                    for k in range(int(len(self.opt_attributes[i])/2)):
                        if self.opt_attributes[i][n+k] == attribute and l[-1].find(value) != -1:
                            #results_list.append(self.features[i])
                            results_list.append(self.features[i+j])
                            results_list.append(self.features[i+j+1])
                        n += 1
            elif attribute == 'back': #back
                if self.filter_runs == 0:
                    results_list = self.features.copy()
                elif self.filter_runs%2 == 0:
                    results_list = self.previous_results_list_even.copy()
                elif self.filter_runs%2 == 1:
                    results_list = self.previous_results_list_odd.copy()    
            elif attribute == 'fasta' or attribute == 'full':
                if self.filter_runs%2 == 1:
                    results_list = self.previous_results_list_even.copy()
                elif self.filter_runs%2 == 0:
                    results_list = self.previous_results_list_odd.copy()
                else:
                    results_list = self.features.copy()
            j += 1
        
        '''Sets copies'''
        if self.filter_runs%2 == 0:
            self.previous_results_list_even = results_list.copy()
        else:
            self.previous_results_list_odd = results_list.copy()
        self.filter_runs += 1
        
        '''Prints. has different functions for fasta, full, back'''
        h = 0
        if attribute == 'fasta':
            print("Found " + str(int(len(self.filtered.features)/2)) + " features!")
            for l in range(int(len(self.filtered.features)/2)):
                #Feature.fasta(results_list[l+h].id, self.sequence.seq,self.filtered.features[l+h])
                Feature.fasta(results_list[l+h].id,self.filtered.features[l+h])
                h += 1
        elif attribute == 'full':
            print("Found " + str(int(len(results_list)/2)) + " features!")
            for l in range(int(len(results_list)/2)):
                Feature.full(results_list[l+h].id,results_list[l+h],results_list[l+h+1])
                h += 1
        else: 
            print("Found " + str(int(len(results_list)/2)) + " features!")
            for l in range(int(len(results_list)/2)):
                Feature.short(results_list[l+h].id,results_list[l+h])
                h += 1

        #self.filtered = SeqRecord(str(self.rootdir),self.sequence,features=results_list)
        self.filtered = SeqRecord(str(self.rootdir),features=results_list)
        return self.filtered

"""
